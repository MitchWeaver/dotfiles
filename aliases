# http://github.com/mitchweaver/dots
#
# this needs organized so bad, possibly split into multiple files
#
# it's a mess, you've been warned...
# 
# * CLEANUP IN PROGRESS *
#
# # # # # # # # # # # # # # # # # # #

# ------------------------ init -------------------------------
# fix shell env variable if its broken
export SHELL=${SHELL:-$0}

# don't break things if we aren't using a compliant shell
case ${SHELL} in
    *ksh|*ash) true ;;
    *) return
esac

# lifehack
alias a=alias

# check if we have installed
has() {
    for _h ; do
        type $_h || return 1
    done > /dev/null 2>&1
}

# check if file/folder exists
exists() {
    for _e ; do
        [ -e $_e ] || return 1
    done
}

# checks if one string contains another
contains() {
    [ $# -ne 2 ] && return 1
    local string="$1"
    local substring="$2"
    if test "${string#*$substring}" != "$string" ; then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# unaliaser
u() {
    for _u ; do 
        unalias $_u || unset -f $_u
    done 2> /dev/null
}

# nobody uses these...
u r w

# find correct python3
for i in 3.7 3.6 3.5 3.4 3 ; do
    if type python$i > /dev/null 2>&1 ; then
        a py3=python$i
        break
    fi
done

# find correct python2
for i in 2.7 2.5 2 ; do
    if type python$i > /dev/null 2>&1 ; then
        a py2=python$i
        break
    fi
done

# set default python
if has py3 ; then
    a py=py3
else
    a py=py2
fi
# --------------------- end init ----------------------------------

# --------------------- OS specific aliases ------------------------
case $(uname) in
    Linux) export NPROC="$(nproc)"
           a disks='lsblk'
           a webcam='ffmpeg -i /dev/video0 -f alsa -i default "$(date)".mp4'
           ;;
    OpenBSD) export NPROC=$(sysctl -n hw.ncpu)
             a sudo=doas
             a seq=jot
             a disks='sysctl -n hw.disknames'
             a disklabel='doas disklabel -h'
             a killall='pkill -9'
             a poweroff='doas shutdown -p now'
             a webcam='ffmpeg -i /dev/video0 -f sndio -i default "$(date)".mp4'
esac
# ---------------- end OS specific aliases -------------------------

# dynamic 'c' utility
c() {
    if [ $# -eq 0 ] ; then
        clear
    elif [ -d "$1" ] ; then
        cd "$1"
    elif [ -f "$1" ] ; then
        cat "$1"
    fi
}

# ls stuff
if has exa ; then
    a ls='exa -F'
elif has colorls ; then
    a ls='colorls -F'
else
    case $(uname) in
        Linux) a ls='ls -F --color=always' ;;
        *BSD)  a ls='ls -F'
    esac
fi

# better clear function, but doesn't work in dvtm
if ! pgrep -x dvtm > /dev/null ; then
    a clear='printf "\033c"'
fi

a cmd=command
a {cc,cll,clear,clar,clea}=clear
a {x,xx,xxx,q,qq,qqq,:q,:Q,:wq,:w,exi}=exit
a {l,sls,sl}=ls
a ll='l -l'
a la='l -a'
a lt='cmd ls -halt'
a {lla,lal}='l -al'
a lsf='l "$PWD"/*'
a {cls,csl,cl,lc}='c;l'
a {e,ech,eho}=echo
a err='>&2 e'
a {g,Grep,gerp}=grep
a {pg,pgrep}='pgrep -f'
a pkill='pkill -f'
a dg='du | g -i'
a lg='ls | g -i'
a cp='cp -irv'
a mv='mv -iv'
a {mkdir,mkd,mkdr}='mkdir -p'
a df='df -h'
a ag='a | g -i'
a file='file -b -i -L'
a bn=basename
a {d,date}="cmd date '+%a %b %d - %I:%M %p'"
a dmegs=dmesg
a man='man -a'
a h='head -n 15'
a t='tail -n 15'
a {w,watch}='watch -t -n 1'
a ex=export
a cx='chmod +x'
a chown='chown -R'
a poweroff='sudo poweroff'
a {reboot,restart}='sudo reboot'

# gnu make
a make="make -j$(( $NPROC + 1 ))"
a makec='make clean'
a makei='make install'
a makeu='make uninstall'
# plan9 make
a mkc='mk clean'
a mki='mk install'
a mku='mk uninstall'

a {xs,xc}='xsel -o ; e'
a rsync='rsync -rtvuh4 --progress --delete' #-c
a sshd='sudo /usr/sbin/sshd'
a scp='scp -rp4'
a diff='diff -u'
a {less,les}='less -QRd'
a view='${EDITOR} -R'
a {htpo,hto,ht,hpot,hotp,top}='htop'
a {hm,hme}='htop -u ${USER}'
a {hr,hroot}='htop -u root'
a nf=neofetch
a {rtv,reddit}='rtv --enable-media ; c'
a compton='pkill compton ; compton & c'
a feh='feh -q -N -x -X -s -Z --scale-down --title feh'
a weather='curl -s wttr.in/madison,sd?m0TQ'
a forecast='curl -s http://wttr.in/madison,sd?m | \
   tail -n 33 | sed $\ d | sed $\ d'
a heart='printf "%b\n" "\xe2\x9d\xa4"'
a chroot='sudo chroot'
a click='xdotool click 1'
a su='su -'

ps() {
    if [ $# -gt 0 ] ; then
        cmd ps auwwx | g -i "$@" | g -v grep
    else
        cmd ps auwwx
    fi | head -n 20
}

mkcd() { mkd "$_" && cd "$_" ; }
mvcd() { mv "$1" "$2" && cd "$2" ; }
cpcd() { cp "$1" "$2" && cd "$2" ; }

du() { 
    [ $# -eq 0 ] && set .
    # gnu
    { command du -ahL --max-depth=1 "$1" | sort -rh ; } ||
    # busybox / BSD
    { command du -ahLd 1 "$1" | sort -r ; } |
    head -n 20
} 2> /dev/null

# run a given command X times
run() { 
    [ $# -lt 2 ] && exit 1
    local c=$1 ; shift
    for i in $(seq $c) ; do 
        "$@"
    done 
}

# files
f() { 
    case $# in
        1) set . "$@" ;;
        0) read inp && set . "$inp"
    esac

    find "$1" ! -path "$1" -iname "*$2*" ; 
}

# folders
ff() { 
    case $# in
        1) set . "$@" ;;
        0) read inp && set . "$inp"
    esac

    find "$1" ! -path "$1" -type d -iname "*$2*" ; 
}

# exec a command on a given file/folder
fdo() {
    case $# in
        # syntax: <folder> <command to be run>
        2) set . "$@" ;;
        # no args = try to read from pipe
#        0) read inp && set . "$inp"
        *) return
    esac

    local dir="$1"
    local string="$2"
    shift 2
    
    if contains "$@" '{}' ; then
        local cmd="$@"
    else
        local cmd="$@ {}"
    fi

    find "$dir" ! -path "$dir" -iname "*$string*" -exec $cmd \; 
}

echossh() {
    if [ $# -lt 3 ] ; then
        >&2 echo 'usage: echossh user@host file $@'
        exit 1
    else
        local user_at_host="$1"
        local file="$2"
        shift 2
        echo "$@" | ssh "$user_at_host" \
            sh -c "cat /dev/stdin >> $file"
    fi
}

ps1() { export PS1='% ' ; }

# search history for command
hg() {
    if [ $# -gt 0 ] ; then
        g -e "$@" $HISTFILE | head -n 20
    fi
}

ext() { e "${1##*.}" ; }
filename() { e "${1%.*}" ; }
cheat() { curl -s cheat.sh/$1 ; }
rgb2hex() { printf "#%02x%02x%02x\n" "$@" ; }

reload() {
    . ~/etc/aliases
    xrdb load ~/etc/Xresources
    xmodmap ~/etc/Xmodmap
    xset m 0 0 
    xset b off 
    xset +fp /home/mitch/.fonts
    xset fp rehash
    fc-cache
} 2> /dev/null

ping() {
    if [ $# -eq 0 ] ; then
        if ${HOME}/bin/online ; then
            echo Online!
        fi
    else
        /bin/ping "$@"
    fi
}

if has nasm ; then
    nasm() {
        if [ -f "$1" ] ; then
            cmd nasm -f elf32 -g -F dwarf "$1" &&
                ld -m elf_i386 "${1%.*}.o" -o "${1%.*}"
        fi
    }
fi

if has w3m ; then
    w3m() {
        if [ $# -eq 0 ] ; then
            set https://ddg.gg/lite
        fi
        cmd w3m -F "$@"
    }

    wtf() {
        w3m -dump http://wtfismyip.com | \
            head -n 15 | \
            sed 's/                    //'
    }
fi

if exists ${HOME}/bin/bar ; then
    bar() {
        pkill bar
        ${HOME}/bin/bar &
    } > /dev/null
fi

if exists ${HOME}/bin/conv ; then
    getconvs() {
        for i in dec bin hex oct ; do
            for j in dec bin hex oct ; do
                [ $i != $j ] &&
                    a ${i}2${j}="${HOME}/bin/conv \
                        -i $(printf %.1s $i) \
                        -o $(echo -n ${j%??} | sed 's/.*2//')"
            done
        done
    }
fi

if has busybox ; then
    has vi || a vi='busybox vi'
    has ash || a ash='busybox ash'
fi

v() { 
    # find which editor we're using
    for i in nvim vim vis vi nano ; do
        if has $i ; then
            local editor=$i
            break
        fi
    done
    if [ -z "$editor" ] ; then
        if has busybox ; then
            editor='busybox vi'
        else
            return
        fi
    fi

    # if no arguments, open my vimwiki page
    if [ $# -eq 0 ] ; then
        if [ -d ${HOME}/var/files/vimwiki ] ; then
            if [ $editor = nvim ] || [ $editor = vim ] ; then
                set -- -c VimwikiIndex
            fi
        fi
        $editor "$@"
    fi

    # fuzzy-find file / recurse down
    if [ -f *"$@"* ] ; then
       $editor *"$@"*
    else
        local f="$(find . -iname *"$@"* -maxdepth 1 | head -n 1)"
        if [ -f "$f" ] ; then
            $editor "$f"
        else
            local f="$(find . -iname *"$@"* -maxdepth 2 | head -n 1)"
            if [ -f "$f" ] ; then
                $editor "$f"
            else
                $editor "$@"
            fi
        fi
    fi
} 2> /dev/null

if has ranger ; then
    r() { ranger "$@" ; c ; }
fi

if has pv ; then
    a pv='pv -pcre'
fi

if has mpv ; then
    mpv() { 
        [ $# -eq 0 ] && return 1

        # kill any currently running mpv before launching a new
        if pgrep xwinwrap > /dev/null ; then
            # kill all mpv except the one with the mpvbg pid
            # as not to kill our desktop background! see ~/bin/mpvbg for details
            kill $(pgrep -a mpv | grep -v mpvbg | awk '{print $1}')
        else
            pkill mpv
        fi > /dev/null 2>&1

        cmd mpv --title=mpv "$@"
    }
    mpvm() { mpv --no-video "$@" ; }
fi

if has mogrify ; then
    75%() { mogrify -resize '75%X75%' "$@" ; }
    50%() { mogrify -resize '50%X50%' "$@" ; }
    25%() { mogrify -resize '25%X25%' "$@" ; }
fi

if has trans ; then
    trans() {
        [ $# -eq 0 ] && read inp && set "$inp"
        cmd trans -no-auto -b "$@"
    }
    rtrans() {
        [ $# -eq 0 ] && read inp && set "$inp"
        # note: $1 needs to be language code, ex: 'de'
        cmd trans -from en -to "$@"
    }
    # german
    rde() {
        [ $# -eq 0 ] && read inp && set "$inp"
        rtrans de "$*"
    }
fi

if has git ; then
    a gmote='git remote add origin'
    a gstat='git status'
    a gbort='git rebase --abort'
    a gcherry='git cherry-pick'
    a gsub='git submodule'
    a {gcheck,checkout}='git checkout'
    gup() { 
        git add -A &&
        git commit -m "$@" &&
        git push -u origin $(git rev-parse --symbolic-full-name --abbrev-ref HEAD)
    }
    gmit() { 
        if [ $# -eq 1 ] ; then
            git add -A &&
            git commit -m "$@"
        elif [ $# -gt 1 ] ; then
            git add "$1" &&
            shift &&
            git commit -m "$@"
        fi
    }
    gout() { git push -u origin $(git rev-parse --abbrev-ref HEAD) "$@" ; }
    gadd()   { [ $# -eq 0 ] && set -- -A  ; git add "$@"               ; }
    gdiff()  { [ $# -eq 0 ] && set master ; git diff origin/"$1"       ; }
    greset() { [ $# -eq 0 ] && set 10     ; git reset --hard HEAD~"$1" ; }
    gbase()  { [ $# -eq 0 ] && set 5      ; git rebase -i HEAD~$1      ; }
    ghclone() { git clone https://github.com/"$1" ; }

    # sets up a git repo in /tmp that you can push/pull from your directory
    # good for backup when working on quick new ideas / scratchpads
    gtmp() { 
        [ $# -eq 0 ] && set -- "/tmp/$(basename ${PWD})-repo"
        git init --bare "$1" &&
        git init .
        git remote add origin "$1" &&
        git add -A &&
        git commit -m "initial commit" &&
        git push -u origin master
    }
fi

# ----------------- movement commands -----------------------
a {..,cd..}='cd ..'
a ...='.. ; ..'
a ....='.. ; ...'

# directory marking
# usage: 'm1' = mark 1
#        'g1' = return to m1
for i in 1 2 3 4 5 6 7 8 9 ; do
    eval "m${i}() { export _MARK${i}=\$PWD ; }"
    eval "g${i}() { cd \$_MARK${i} ; }"
done

_g() { local a=$1 ; shift ; cd $a/"$@" ; cl ;  }

for i in bin env etc tmp usr var src ; do
    if exists ~/$i ; then
        a g$(printf %.1s $i)="_g ~/$i"
    fi
    a g$(printf %.1s $i | tr [a-z] [A-Z])="_g /$i"
done

a gM='_g /mnt'
case ${SHELL} in
    *ksh|bash)
        g~() { cd ~          ; }
        m~() { mv "$@" ~     ; }
        Y~() { cp "$@" ~     ; }
esac
mT() { mv "$@" /tmp  ; }
YT() { cp "$@" /tmp  ; }

if exists ~/var ; then
    for i in downloads files images music ; do
        a g$(printf %.1s $i)="_g ~/var/$i"
    done

    a {gvi,gvid}='_g ~/var/videos'
    a gbk='_g ~/var/books'
    a gvt='_g ~/var/tmp'
    a gyt='_g ~/.youtube-dl'

    Yf() { cp "$@" ~/var/files     ; }
    Yd() { cp "$@" ~/var/downloads ; }
    Yi() { cp "$@" ~/var/images    ; }
    Ym() { cp "$@" ~/var/music     ; }
    Yvi(){ cp "$@" ~/var/videos    ; }

    mf() { mv "$@" ~/var/files     ; }
    md() { mv "$@" ~/var/downloads ; }
    mi() { mv "$@" ~/var/images    ; }
    mm() { mv "$@" ~/var/music     ; }
    mvi(){ mv "$@" ~/var/videos    ; }
fi

if exists ~/usr ; then
    a gr='_g ~/usr/repos' 
    a gbkup='_g ~/usr/backup'
    mu() { mv "$@" ~/usr ; }
    mr() { mv "$@" ~/usr/repos ; }
    Yu() { cp "$@" ~/usr ; }
    Yr() { cp "$@" ~/usr/repos ; }
fi

if exists ~/etc ; then
    me() { mv "$@" ~/etc ; }
    Ye() { cp "$@" ~/etc ; }
    a gcf='_g ~/etc/config'

    a {aliases,alaises,aliase}='v ~/etc/aliases'
    a profile='v ~/etc/profile'
    a {bmk,bmks}='v ~/var/files/bookmarks/bookmarks.txt'
    a {vssh,sshv}='v ~/.ssh/config'

    for i in vim ksh xinit ; do
        a ${i}rc="v ~/etc/${i}rc"
    done

    for i in dwm st surf tabbed dmenu ; do
        a ${i}cfg="v ~/etc/suckless/$i/config.h"
        a ${i}c="v ~/etc/suckless/$i/$i.c"
    done
    recomp() {
        for i ; do
            ~/bin/recomp ~/etc/suckless/$i
        done
    }
fi

if exists ~/src ; then
    a gs='_g ~/src'
    ms() { mv "$@" ~/src ; }
    Ys() { cp "$@" ~/src ; }
fi

if exists ~/bin ; then
    mb() { mv "$@" ~/bin ; }
    Yb() { cp "$@" ~/bin ; }
fi

if exists ~/tmp ; then
    mt() { mv "$@" ~/tmp ; }
    Yt() { cp "$@" ~/tmp ; }
fi

if exists ~/env ; then
    mn() { mv "$@" ~/env ; }
    Yn() { cp "$@" ~/env ; }
    a gn='_g ~/env'
fi
# ----------- end movement commands ------------------

if exists ~/.youtube-dl ; then
    addyt() { 
        for i ; do
            echo "$i" >> ~/.youtube-dl/video-queue.txt
        done
    }
    addytm() {
        for i ; do
            echo "$i" >> ~/.youtube-dl/music-queue.txt
        done
    }
    checkyt() { tail -f /tmp/ytdl*.log ; }

    ytdlm() { 
        for i ; do
            youtube-dl --geo-bypass --prefer-ffmpeg --extract-audio \
                --audio-quality 0 --audio-format opus "$i"
        done
    }
    ytdl() { 
        for i ; do
            youtube-dl --geo-bypass --prefer-ffmpeg "$i"
        done
    }
fi

if has pk ; then
    gpk() { cd ~/.local/pk/prefix ; cls ; }
fi

if exists ~/var ; then
    mvwait() {
        for i ; do
            mv "$i" ~/var/music/waiting_pool
        done
    }
fi

if has cover ; then
    split2flac() {
        if [ "$(find . -maxdepth 1 -iname '*.flac')" ] ; then
            cmd split2flac ./*.flac || return
        elif [ "$(find . -maxdepth 1 -iname '*.wav')" ] ; then
            cmd split2flac ./*.wav || return
        else
            return
        fi
        rm -f *.flac *.wav scans Scans covers Covers *.cue *.log *.txt *.*nfo *.toc *.*rip
        mv -f "`find . -maxdepth 1 ! -path . -type d`"/*/* . && \
            rm -rf "`find . -maxdepth 1 ! -path . -type d`"
        jpg *.png 2> /dev/null
        mv *.jpg cover.jpg
        jpegoptim *.jpg > /dev/null
    }

    fetchcovers() {
        for i in * ; do
            cd "$i" || continue
            a="$(basename "$(echo $PWD | sed -E 's/\/[0-9]+.*//')") - $(echo "$i" | sed -E 's/[0-9]+ - //')"
            echo "$a"
            cover "$a"
            cd ..
        done
    }

    bandlogo() {
        if [ $# -eq 0 ] ; then
            artist=$(basename "$(echo $PWD | \
                sed -E 's/\/[0-9]+.*//' | \
                sed -E 's/ \([A-Z]+[a-z]*\)//')")
            echo "$artist"
            band "$artist"
            logo "$artist"
        else
            band "$@" ; logo "$@"
        fi
    }
    cover() {
        if [ $# -eq 0 ] ; then
            artist=$(basename "$(echo $PWD | \
                sed -E 's/\/[0-9]+.*//' | \
                sed -E 's/ \([A-Z]+[a-z]*\)//')")
            album=$(basename "$PWD" | sed -E 's/[0-9]+ - //' | sed -E 's/ \(.*//')
            echo "$artist - $album"
            cmd cover "$artist - $album"
        else
            cmd cover "$@"
        fi
    }
    songs() {
        if [ $# -eq 0 ] ; then
            artist=$(basename "$(echo $PWD | \
                sed -E 's/\/[0-9]+.*//' | \
                sed -E 's/ \([A-Z]+[a-z]*\)//')")
            album=$(basename "$PWD" | sed -E 's/[0-9]+ - //' | sed -E 's/ \(.*//')
            echo "$artist - $album"
            cmd songs "$artist - $album"
        else
            cmd songs "$@"
        fi
    }
    location() {
        if [ $# -eq 0 ] ; then
            artist=$(basename "$(echo $PWD | \
                sed -E 's/\/[0-9]+.*//' | \
                sed -E 's/ \([A-Z]+[a-z]*\)//')")
            echo "$artist"
            cmd location "$artist"
        else
            cmd location "$@"
        fi
    }
    releases() {
        if [ $# -eq 0 ] ; then
            artist=$(basename "$(echo $PWD | \
                sed -E 's/\/[0-9]+.*//' | \
                sed -E 's/ \([A-Z]+[a-z]*\)//')")
            echo "$artist"
            cmd releases "$artist"
        else
            cmd releases "$@"
        fi
    }
    genre() {
        if [ $# -eq 0 ] ; then
            artist=$(basename "$(echo $PWD | \
                sed -E 's/\/[0-9]+.*//' | \
                sed -E 's/ \([A-Z]+[a-z]*\)//')")
            echo "$artist"
            cmd genre "$artist"
        else
            cmd genre "$@"
        fi
    }
    fehcover() {
        _PWD=$PWD
        cd /tmp
        cover "$@" && feh ./cover.jpg 2> /dev/null
        [ -f ./cover.jpg ] && rm -f ./cover.jpg
        cd "$_PWD"
    }
    fehlogo() {
        _PWD=$PWD
        cd /tmp
        logo "$@" && feh ./logo.jpg 2> /dev/null
        [ -f ./logo.jpg ] && rm -f ./logo.jpg
        cd "$_PWD"
    }
fi

if has pape ; then
    a save_wall='cp ${HOME}/var/tmp/wall ${HOME}/var/images/wallpapers/unsplash/saved_"$(date)".png'
fi

if has clamscan ; then
    clam() {
        if [ -e "$1" ] ; then
            sudo clamscan -r "$1" --move=/tmp/quar/ --log=/tmp/quar/log.txt
        fi
    }
fi

# unalias loop/tmp variables
u i j _u _p _h
